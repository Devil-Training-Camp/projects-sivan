# 项目总结文档

## 使用技术

### 前端

`React` + `TypeScript` + `Vite` + `Ant Design` + `Axios` + `Scss`

### 服务端

`Koa` + `TypeScript`

## 系统关键设计说明

### 前端

- 选择文件
  - 将文件保存到 filesList （多文件上传），渲染出每一个文件上传组件
- 上传文件
  1. 生成文件切片，使用 `File.prototype.slice` 方法
  2. 生成文件 hash，使用 `FileReader` 的 `readAsArrayBuffer` 方法将每一个切片转化为 `ArrayBuffer`，并使用 `spark-md5` 对象的 `append` 方法进行追加（同时这个过程中通过 updateHashProgress 回调函数更新文件 hash 计算进度），最终通过 `end` 方法计算出整个文件的 hash 并返回
  3. 使用 `Web Worker` 优化计算文件 hash 过程，防止阻塞主线程
  4. 保存文件 hash，通过文件 hash 请求查询服务端文件是否已经上传
     - 文件已上传，前端直接更新上传进度并通过 `message` 提示“上传成功”，实现秒传
     - 否则，服务端返回已上传的文件切片（如果有）
  5. 上传切片，构造切片数据结构，根据服务端返回的已上传切片过滤，得到新的切片列表并上传
     - 通过 `AbortController` 实现暂停上传
     - 通过 `onUploadProgress` 实现上传进度更新
  6. 并发控制，封装并发控制类实现最大并发控制、请求错误重试，优化切片上传
  7. 合并切片，切片全部上传后，前端额外发送请求通知服务端合并切片
     - 上传成功，`message` 提示“上传成功”
     - 否则，`message` 提示错误信息
- 暂停上传（只能在文件上传的过程中操作）
  1. 暂停，在上传的接口中对于每个切片请求传入了 `signal` 实例，在这里直接通过 `abort` 方法暂停上传
  2. 继续，从上传文件**第4步**逻辑开始往下走

### 服务端

- 上传切片接口
  1. 获取切片保存路径，通过 `mkdir` 方法以及它的第二个参数 `{ recursive: true }` 判断目录是否存在，如果不存在先创建目录
  2. 保存切片，通过 `writeFile` 方法保存切片
- 合并切片接口
  1. 获取切片保存路径，通过 `stat` 的 `isDirectory` 方法判断目录是否存在
     - 目录存在
       1. 使用 `readdir` 遍历目录获取所有切片文件，再通过 `pipeline` 和 `Stream` 流并发读取合成切片
       1. 切片合成之后删除切片保存目录
- 验证文件是否上传接口
  1. 获取文件保存路径，通过 `stat` 的 `isFile` 方法判断文件是否存在
     - 文件存在，直接返回 `true`
     - 文件不存在，遍历切片保存目录获取已上传的切片，返回 `false` 和已上传的切片

## 流程图

[流程图](https://www.yuque.com/u1598738/ryg73d/gdn0v4fymgple6fq/edit?toc_node_uuid=An_1-N79hHVVoomg#hQgbu)

## 开发过程中碰到的问题

1. 更新切片上传进度时，直接修改每一个切片的 `progress` 不生效
   - 因为是使用数组保存的切片数据，react 无法监听到数组内部的变化，修改时需要返回一个新的数组，然后去 set 这个新数组
2. 通过并发控制类优化切片上传时，直接传入了 `uploadChunk(uploadParams)` 导致 macOS 下上传进度统计出错
   - 这种实际上是传入了一个已经执行的 Promise 到任务队列，导致切片上传进度统计出现部分丢失，应该传入一个未执行的 Promise 在任务队列内部执行，`() => uploadChunk(uploadParams)`
3. 封装并发控制类的时候在内部使用了 `async await` 的操作
   - `async await` 会造成阻塞的效果，导致并发控制不生效，修改为 `.then().catch()` 的调用方式
4. 因为是采用前端发送请求通知服务端合成切片，合成切片请求发送的时机是什么时候？如何知道？
   - **发送的时机是所有切片成功上传之后**，那么前端怎么知道切片已经全部上传到服务端了，上传的时候给每个切片都加上最大切片数，服务端每接收一个切片就判断一下是不是最后一个切片，最后再返回一个标识给前端？好像有点多此一举，不如直接服务端自己判断合成切片
   - 希望前端自己发送请求，那么判断也应该在前端，给并发控制类多一个 `successfulTasks` 任务执行成功数，在 `.then` 里统计，最后通过一个 `callback` 返回
5. 在一次上传过程中多次暂停上传，导致上传进度条统计出错
   - 这种操作可能导致切片已经上传，但是请求被打断，部分进度没能及时更新，最后统计出现误差，通过每次继续上传之前拿到所有已上传的切片，手动将已上传的切片进度更新到 100 ，然后重新去 set 一下切片数组
